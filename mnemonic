Full Mnemonic Map
Step 1 â†’ Requirements & Clarifications

Mnemonic: CLEAR

Clarify functional & non-functional (latency, durability).

Load & scale (req/sec, DAU).

Estimate data size & growth.

Assumptions explicit.

Review & get buy-in.

ğŸ‘‰ Remember: â€œCLEAR requirements first.â€

Step 2 â†’ API & Data Modeling

Mnemonic: PRISM

Pagination

Rate limiting

Indexing/sharding choice

SQL vs NoSQL trade-offs

Modeling (entities, relations, GSIs)

ğŸ‘‰ Remember: â€œAPIs are a PRISM to see the data model.â€

Step 3 â†’ Component Design

Mnemonic: BOXFOM

Bottlenecks

Observability (metrics, logging, tracing)

X (Cross failures â†’ think partial outages)

Failure points (graceful degradation)

On-demand scaling (horizontal partitioning, CDN, cache)

Microservices/components (DB, queue, LB, workers)

ğŸ‘‰ Remember: â€œBox the system into components with FOM (failure, observability, microservices).â€

Step 4 â†’ Scaling & Trade-offs

Mnemonic: LAST

Latency vs throughput trade-offs

Availability vs durability vs consistency (CAP)

Security (auth, rate limits)

Trade-offs wrap-up (cost vs complexity vs scale)

ğŸ‘‰ Remember: â€œAlways discuss the LAST trade-offs.â€

âœ… Combined Flow Mnemonic

Top-level: R-A-C-S â†’ Real Architects Craft Systems

Inside: CLEAR â†’ PRISM â†’ BOXFOM â†’ LAST

So in interview, your brain runs like this:
ğŸ‘‰ R (CLEAR) â†’ A (PRISM) â†’ C (BOXFOM) â†’ S (LAST).
