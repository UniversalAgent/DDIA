Data models summary

| Aspect                     | Relational (SQL)                                       | Document (Mongo/Cosmos)                            | Graph (Neo4j/Arango)                             | Key-Value (Redis/Dynamo)                | Mnemonic / Recall                                                   |
| -------------------------- | ------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------ | --------------------------------------- | ------------------------------------------------------------------- |
| **Schema**                 | Rigid, schema-first                                    | Flexible / schema-less                             | Flexible / node properties                       | Flexible, key-value                     | Schema rigidity vs flexibility                                      |
| **Data Organization**      | Tables, rows, columns                                  | JSON documents (nested)                            | Nodes & edges                                    | Key ‚Üí value                             | Think ‚ÄúNormalize vs Embed vs Edge vs KV‚Äù                            |
| **Filtering**              | ‚úîÔ∏è Rich predicates                                     | ‚úîÔ∏è Field-level                                     | ‚úîÔ∏è Node/edge props                               | ‚ùå Key-only                              | F in F-P-S-A-J-N-T-L                                                |
| **Projection**             | ‚úîÔ∏è Select columns                                      | ‚úîÔ∏è Pick fields                                     | ‚úîÔ∏è Return props                                  | ‚ùå Whole value                           | P in mnemonic                                                       |
| **Sorting / Pagination**   | ‚úîÔ∏è ORDER BY LIMIT                                      | ‚úîÔ∏è sort().limit()                                  | ‚úîÔ∏è ORDER BY LIMIT                                | ‚ö†Ô∏è Key order only                       | S-L in mnemonic                                                     |
| **Aggregation**            | ‚úîÔ∏è GROUP BY, COUNT, SUM, AVG                           | ‚úîÔ∏è `$group`, `$unwind`                             | ‚ö†Ô∏è Basic                                         | ‚ùå None                                  | A in mnemonic                                                       |
| **Joins / Relationships**  | ‚úîÔ∏è Multi-table joins                                   | ‚ö†Ô∏è `$lookup` limited                               | ‚úîÔ∏è Native traversals                             | ‚ùå None                                  | J in mnemonic                                                       |
| **Nested / Hierarchical**  | ‚ö†Ô∏è Needs joins                                         | ‚úîÔ∏è Natural JSON nesting                            | ‚úîÔ∏è Edges = hierarchy                             | ‚ö†Ô∏è Only if JSON value                   | N in mnemonic                                                       |
| **Text Search**            | ‚ö†Ô∏è LIKE / full-text plugin                             | ‚úîÔ∏è Built-in                                        | ‚ö†Ô∏è Basic                                         | ‚ùå None                                  | T in mnemonic                                                       |
| **Limits / Pagination**    | ‚úîÔ∏è LIMIT OFFSET                                        | ‚úîÔ∏è .limit().skip()                                 | ‚úîÔ∏è LIMIT                                         | ‚ö†Ô∏è Batch reads                          | L in mnemonic                                                       |
| **Pros**                   | Reliable ACID, rich queries, mature                    | Flexible schema, nested aggregates, easy evolution | Relationships & traversal-first, intuitive       | Blazing fast, scalable, simple          | R-D-G-K = Reliable, Duplication, Graph, Key                         |
| **Cons**                   | Joins across shards slow, rigid schema, vertical scale | Data duplication ‚Üí consistency risk, weak joins    | Poor for aggregation, sharding hard, less mature | Minimal queries, modeling burden on app | Rigid-Duplication-GraphHard-KeySimple                               |
| **Example Use Cases**      | üí≥ Banking / payments, üì¶ Inventory                    | üõí Catalog, üì± User profiles                       | üë• Social graph, üïµÔ∏è Fraud detection             | ‚ö° Cache, üõí Cart, üèÜ Leaderboards       | Emojis anchor use cases                                             |
| **Trade-off / Why Choose** | Complex queries + consistency needed                   | Aggregates / nested queries / flexible schema      | Relationship-heavy queries                       | Speed / simple access patterns          | Answer ‚Äúbased on Query Pattern + Scale + Consistency + Flexibility‚Äù |


Interview Tip: Choose DB based on Query Pattern + Scale + Consistency + Flexibility

| Step                  | Question to Ask                 | What to Look For                                                          | DB Implication / Example                                                                                                    |
| --------------------- | ------------------------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **Q ‚Äì Query Pattern** | What queries dominate?          | Joins, aggregations, nested objects, relationships, key lookups           | Relational ‚Üí joins/aggregates, Document ‚Üí nested objects, Graph ‚Üí relationships, Key-Value ‚Üí key lookups                    |
| **S ‚Äì Scale**         | How much data/traffic?          | Millions of users, billions of events, spikes, geo-scale                  | Key-Value ‚Üí horizontal + low latency, Document ‚Üí scalable nested reads, Relational ‚Üí vertical scale, Graph ‚Üí moderate scale |
| **C ‚Äì Consistency**   | Strong consistency required?    | ACID vs eventual consistency                                              | Relational ‚Üí ACID, Document ‚Üí eventual ok, Graph ‚Üí depends on traversal, Key-Value ‚Üí eventual acceptable                    |
| **F ‚Äì Flexibility**   | Will schema evolve?             | Frequent new fields, nested objects                                       | Document ‚Üí flexible, Graph ‚Üí flexible nodes/edges, Relational ‚Üí rigid, Key-Value ‚Üí flexible but simple                      |
| **Mnemonic**          | Quick Scalable Choices Flexibly | Remember order Q-S-C-F                                                    | ‚ÄúQuick Students Can Focus‚Äù                                                                                                  |
| **Example 1**         | Twitter timeline                | Key lookup, billions of tweets, eventual consistency, schema mostly fixed | Key-Value store (DynamoDB / Redis)                                                                                          |
| **Example 2**         | Bank ledger                     | Multi-field joins, millions of accounts, strong ACID, schema stable       | Relational DB                                                                                                               |


 example practise
  | Example System                          | Query Pattern (Q)                                   | Scale (S)                             | Consistency (C)               | Flexibility (F)        | Rough Schema                                                                                                        | Example Query                                                                                                                                | DB Choice & Reasoning                                                                     |
| --------------------------------------- | --------------------------------------------------- | ------------------------------------- | ----------------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Twitter Timeline**                    | Key lookups by user ID                              | Millions of users, billions of tweets | Eventual consistency          | Schema mostly fixed    | `Timeline(user_id PK, tweet_id, timestamp)`                                                                         | `GET Timeline WHERE user_id = 123 ORDER BY timestamp DESC LIMIT 50`                                                                          | **Key-Value** ‚Üí Fast lookups, massive scale, eventual consistency ok                      |
| **Bank Ledger / Payments**              | Multi-table joins                                   | Millions of accounts                  | Strong ACID                   | Schema stable          | `Accounts(account_id PK, user_id, balance)`, `Transactions(txn_id PK, account_id FK, amount, timestamp)`            | `SELECT a.user_id, SUM(t.amount) FROM Accounts a JOIN Transactions t ON a.account_id = t.account_id WHERE a.user_id = 42 GROUP BY a.user_id` | **Relational** ‚Üí Joins, ACID, strong consistency                                          |
| **E-commerce Catalog**                  | Filter by category, price, nested attributes        | Millions of products                  | Eventual consistency          | Schema may evolve      | `Product(product_id PK, name, category, price, specs JSON)`                                                         | `db.products.find({"category": "laptop", "price": {"$lt": 1000}}).sort({"price": 1}).limit(20)`                                              | **Document DB** ‚Üí Nested JSON, flexible schema, supports filtering & aggregation          |
| **Social Network (Friends-of-Friends)** | Multi-hop relationship traversal                    | Millions of users                     | Eventual/moderate consistency | Nodes/edges may evolve | `User(user_id PK, name)`, `Friendship(user_id1, user_id2, since)`                                                   | `MATCH (u:User {id:123})-[:FRIEND]->(f:User)-[:FRIEND]->(fof:User) RETURN fof`                                                               | **Graph DB** ‚Üí Optimized for relationships and traversals                                 |
| **Session Store / Cache**               | Simple key lookups                                  | Millions of users, high TPS           | Eventual consistency          | Schema fixed           | `Session(user_id PK, session_data JSON, expiry_ts)`                                                                 | `GET Session WHERE user_id = 123`                                                                                                            | **Key-Value** ‚Üí Ultra-low latency, simple access patterns                                 |
| **Fraud Detection (Banking)**           | Traversal across transactions & users               | Millions of accounts & transactions   | Strong consistency            | Nodes may evolve       | `User(user_id PK)`, `Transaction(txn_id PK, user_id FK, amount, timestamp)`, `LinkedTransactions(txn_id1, txn_id2)` | `MATCH (u:User)-[:MADE]->(t:Transaction)-[:LINKED]->(t2:Transaction) RETURN t2 WHERE t.amount > 10000`                                       | **Graph + Relational Hybrid** ‚Üí Graph for relationships, Relational for ACID transactions |
| **User Profiles**                       | Read/update user info, occasional nested attributes | Millions of users                     | Eventual consistency          | Schema may evolve      | `UserProfile(user_id PK, name, email, preferences JSON)`                                                            | `db.userProfiles.find({"user_id":123}, {"name":1, "preferences":1})`                                                                         | **Document DB** ‚Üí Flexible schema, supports nested attributes                             |
