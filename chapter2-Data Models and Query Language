Data models summary

| Aspect                     | Relational (SQL)                                       | Document (Mongo/Cosmos)                            | Graph (Neo4j/Arango)                             | Key-Value (Redis/Dynamo)                | Mnemonic / Recall                                                   |
| -------------------------- | ------------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------ | --------------------------------------- | ------------------------------------------------------------------- |
| **Schema**                 | Rigid, schema-first                                    | Flexible / schema-less                             | Flexible / node properties                       | Flexible, key-value                     | Schema rigidity vs flexibility                                      |
| **Data Organization**      | Tables, rows, columns                                  | JSON documents (nested)                            | Nodes & edges                                    | Key â†’ value                             | Think â€œNormalize vs Embed vs Edge vs KVâ€                            |
| **Filtering**              | âœ”ï¸ Rich predicates                                     | âœ”ï¸ Field-level                                     | âœ”ï¸ Node/edge props                               | âŒ Key-only                              | F in F-P-S-A-J-N-T-L                                                |
| **Projection**             | âœ”ï¸ Select columns                                      | âœ”ï¸ Pick fields                                     | âœ”ï¸ Return props                                  | âŒ Whole value                           | P in mnemonic                                                       |
| **Sorting / Pagination**   | âœ”ï¸ ORDER BY LIMIT                                      | âœ”ï¸ sort().limit()                                  | âœ”ï¸ ORDER BY LIMIT                                | âš ï¸ Key order only                       | S-L in mnemonic                                                     |
| **Aggregation**            | âœ”ï¸ GROUP BY, COUNT, SUM, AVG                           | âœ”ï¸ `$group`, `$unwind`                             | âš ï¸ Basic                                         | âŒ None                                  | A in mnemonic                                                       |
| **Joins / Relationships**  | âœ”ï¸ Multi-table joins                                   | âš ï¸ `$lookup` limited                               | âœ”ï¸ Native traversals                             | âŒ None                                  | J in mnemonic                                                       |
| **Nested / Hierarchical**  | âš ï¸ Needs joins                                         | âœ”ï¸ Natural JSON nesting                            | âœ”ï¸ Edges = hierarchy                             | âš ï¸ Only if JSON value                   | N in mnemonic                                                       |
| **Text Search**            | âš ï¸ LIKE / full-text plugin                             | âœ”ï¸ Built-in                                        | âš ï¸ Basic                                         | âŒ None                                  | T in mnemonic                                                       |
| **Limits / Pagination**    | âœ”ï¸ LIMIT OFFSET                                        | âœ”ï¸ .limit().skip()                                 | âœ”ï¸ LIMIT                                         | âš ï¸ Batch reads                          | L in mnemonic                                                       |
| **Pros**                   | Reliable ACID, rich queries, mature                    | Flexible schema, nested aggregates, easy evolution | Relationships & traversal-first, intuitive       | Blazing fast, scalable, simple          | R-D-G-K = Reliable, Duplication, Graph, Key                         |
| **Cons**                   | Joins across shards slow, rigid schema, vertical scale | Data duplication â†’ consistency risk, weak joins    | Poor for aggregation, sharding hard, less mature | Minimal queries, modeling burden on app | Rigid-Duplication-GraphHard-KeySimple                               |
| **Example Use Cases**      | ðŸ’³ Banking / payments, ðŸ“¦ Inventory                    | ðŸ›’ Catalog, ðŸ“± User profiles                       | ðŸ‘¥ Social graph, ðŸ•µï¸ Fraud detection             | âš¡ Cache, ðŸ›’ Cart, ðŸ† Leaderboards       | Emojis anchor use cases                                             |
| **Trade-off / Why Choose** | Complex queries + consistency needed                   | Aggregates / nested queries / flexible schema      | Relationship-heavy queries                       | Speed / simple access patterns          | Answer â€œbased on Query Pattern + Scale + Consistency + Flexibilityâ€ |


Interview Tip: Choose DB based on Query Pattern + Scale + Consistency + Flexibility

| Step                  | Question to Ask                 | What to Look For                                                          | DB Implication / Example                                                                                                    |
| --------------------- | ------------------------------- | ------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **Q â€“ Query Pattern** | What queries dominate?          | Joins, aggregations, nested objects, relationships, key lookups           | Relational â†’ joins/aggregates, Document â†’ nested objects, Graph â†’ relationships, Key-Value â†’ key lookups                    |
| **S â€“ Scale**         | How much data/traffic?          | Millions of users, billions of events, spikes, geo-scale                  | Key-Value â†’ horizontal + low latency, Document â†’ scalable nested reads, Relational â†’ vertical scale, Graph â†’ moderate scale |
| **C â€“ Consistency**   | Strong consistency required?    | ACID vs eventual consistency                                              | Relational â†’ ACID, Document â†’ eventual ok, Graph â†’ depends on traversal, Key-Value â†’ eventual acceptable                    |
| **F â€“ Flexibility**   | Will schema evolve?             | Frequent new fields, nested objects                                       | Document â†’ flexible, Graph â†’ flexible nodes/edges, Relational â†’ rigid, Key-Value â†’ flexible but simple                      |
| **Mnemonic**          | Quick Scalable Choices Flexibly | Remember order Q-S-C-F                                                    | â€œQuick Students Can Focusâ€                                                                                                  |
| **Example 1**         | Twitter timeline                | Key lookup, billions of tweets, eventual consistency, schema mostly fixed | Key-Value store (DynamoDB / Redis)                                                                                          |
| **Example 2**         | Bank ledger                     | Multi-field joins, millions of accounts, strong ACID, schema stable       | Relational DB                                                                                                               |


 example practise
  | Example System                          | Query Pattern (Q)                                   | Scale (S)                             | Consistency (C)               | Flexibility (F)        | Rough Schema                                                                                                        | Example Query                                                                                                                                | DB Choice & Reasoning                                                                     |
| --------------------------------------- | --------------------------------------------------- | ------------------------------------- | ----------------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------- |
| **Twitter Timeline**                    | Key lookups by user ID                              | Millions of users, billions of tweets | Eventual consistency          | Schema mostly fixed    | `Timeline(user_id PK, tweet_id, timestamp)`                                                                         | `GET Timeline WHERE user_id = 123 ORDER BY timestamp DESC LIMIT 50`                                                                          | **Key-Value** â†’ Fast lookups, massive scale, eventual consistency ok                      |
| **Bank Ledger / Payments**              | Multi-table joins                                   | Millions of accounts                  | Strong ACID                   | Schema stable          | `Accounts(account_id PK, user_id, balance)`, `Transactions(txn_id PK, account_id FK, amount, timestamp)`            | `SELECT a.user_id, SUM(t.amount) FROM Accounts a JOIN Transactions t ON a.account_id = t.account_id WHERE a.user_id = 42 GROUP BY a.user_id` | **Relational** â†’ Joins, ACID, strong consistency                                          |
| **E-commerce Catalog**                  | Filter by category, price, nested attributes        | Millions of products                  | Eventual consistency          | Schema may evolve      | `Product(product_id PK, name, category, price, specs JSON)`                                                         | `db.products.find({"category": "laptop", "price": {"$lt": 1000}}).sort({"price": 1}).limit(20)`                                              | **Document DB** â†’ Nested JSON, flexible schema, supports filtering & aggregation          |
| **Social Network (Friends-of-Friends)** | Multi-hop relationship traversal                    | Millions of users                     | Eventual/moderate consistency | Nodes/edges may evolve | `User(user_id PK, name)`, `Friendship(user_id1, user_id2, since)`                                                   | `MATCH (u:User {id:123})-[:FRIEND]->(f:User)-[:FRIEND]->(fof:User) RETURN fof`                                                               | **Graph DB** â†’ Optimized for relationships and traversals                                 |
| **Session Store / Cache**               | Simple key lookups                                  | Millions of users, high TPS           | Eventual consistency          | Schema fixed           | `Session(user_id PK, session_data JSON, expiry_ts)`                                                                 | `GET Session WHERE user_id = 123`                                                                                                            | **Key-Value** â†’ Ultra-low latency, simple access patterns                                 |
| **Fraud Detection (Banking)**           | Traversal across transactions & users               | Millions of accounts & transactions   | Strong consistency            | Nodes may evolve       | `User(user_id PK)`, `Transaction(txn_id PK, user_id FK, amount, timestamp)`, `LinkedTransactions(txn_id1, txn_id2)` | `MATCH (u:User)-[:MADE]->(t:Transaction)-[:LINKED]->(t2:Transaction) RETURN t2 WHERE t.amount > 10000`                                       | **Graph + Relational Hybrid** â†’ Graph for relationships, Relational for ACID transactions |
| **User Profiles**                       | Read/update user info, occasional nested attributes | Millions of users                     | Eventual consistency          | Schema may evolve      | `UserProfile(user_id PK, name, email, preferences JSON)`                                                            | `db.userProfiles.find({"user_id":123}, {"name":1, "preferences":1})`                                                                         | **Document DB** â†’ Flexible schema, supports nested attributes                             |
